/*
***** Н А Ч А Л О   файла компилятора с языка высокого уровня
*/

/*
***** Б л о к  об'явлений макроопределений
*/

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
/* п р е д е л ь н ы е    */
/* размеры:               */
#define MAXNISXTXT 50                             /* - исходного текста;    */
#define NSINT     239                             /* - табл.синтакс.правил; */
#define NCEL       20                             /* - стека целей;         */
#define NDST      500                             /* - стека достижений;    */
#define NVXOD      59                             /* - табл.входов;         */
#define NSTROKA   200                             /* - строки плотн.текста; */
#define NNETRM     20                             /* - списка нетерминалов; */
#define MAXLTXT    50                             /* - выходного текста;    */
#define MAXFORMT   30                             /* - форматированного ин- */
/* терпретируемого  фраг- */
/* мента исх.текста;      */
#define NSYM      100                             /* - таблицы имен и меток */

/*
***** Б а з а  данных компилятора
*/

/*
***** Б л о к  об'явления массива с исходным текстом
*/

int  NISXTXT;                                     /* длина массива          */
char ISXTXT [MAXNISXTXT][80];                     /* тело массива           */

/*
***** Б л о к  об'явления рабочих переменных
*/

int I1,I2,I3,I4;                                  /* счетчики циклов        */

char PREDSYM = ' ';                               /*последний обработанный  */
/*символ в уплотненном    */
/*исходном тексте         */

char STROKA [ NSTROKA ];                          /*место хранения уплотнен-*/
/*ного исходного текста   */

int I,J,K,L;                                      /*текущие индексы соответ-*/
/*ственно в:              */
/* - уплотненном тексте;  */
/* - табл.грамм.правил;   */
/* - стеке поставленных   */
/*целей;                  */
/* - стеке достигнутых    */
/*целей;                  */

union                                             /*шаблон для генерации    */
{                                                /*записи выходного файла  */
  char    BUFCARD [80];                           /*на АССЕМБЛЕРЕ IBM 370   */
  struct
  {
    char METKA   [8];
    char PROB1;
    char OPERAC  [5];
    char PROB2;
    char OPERAND [12];
    char PROB3;
    char COMM    [52];
  } _BUFCARD;
} ASS_CARD ;

char ASSTXT [ MAXLTXT ][80];                      /*массив для хранения     */
/*выходного текста на     */
/*АССЕМБЛЕРЕ IBM 370      */

int  IASSTXT;                                     /*индекс выходного массива*/

char FORMT [MAXFORMT] [9];                        /*массив для форматирован-*/
/*ного  (в виде последова-*/
/*тельности 9-ти позицион-*/
/*ных строк-лексем) пред- */
/*ставления интерпретиру- */
/*емого фрагмента исходно-*/
/*го плотного текста      */

int  IFORMT;                                      /*индекс форматированного */
/*массива                 */
/*
***** Б л о к  об'явления таблиц базы данных
*/

/*
***** Т а б л и ц а, используемая как магазин (стек) достижений
*/

struct
{
  char DST1 [ 4 ];
  int  DST2;
  int  DST3;
  int  DST4;
  int  DST5;
} DST [ NDST ];

/*
***** Т а б л и ц а, используемая как магазин (стек) целей
*/

struct
{
  char CEL1 [ 4 ];
  int  CEL2;
  int  CEL3;
} CEL [ NCEL ];

/*
***** Т а б л и ц а, синтаксических правил, записанных в форме распознавания,
***** сгруппированных в "кусты" и представленных в виде двухнапрвленного
***** списка с альтернативными разветвлениями
*/

struct
{
  int  POSL;
  int  PRED;
  char DER[4];
  int  ALT;
} SINT [ NSINT ] =
/*   __________ _________ _______ _______ ______
    |  NN      :    посл : пред  :  дер  : альт |
    |__________:_________:_______:_______:______|                          */
    {
        {/*.    0     .*/    -1 ,    -1 , "***" ,   -1 },
        /*                                               вход с символа - OPR    */
        {/*.    1     .*/     2 ,     0 , "OPR" ,    0 },
        {/*.    2     .*/     3 ,     1 , "TEL" ,    0 },
        {/*.    3     .*/     4 ,     2 , "OEN" ,    0 },
        {/*.    4     .*/     5 ,     3 , "PRO" ,    0 },
        {/*.    5     .*/     0 ,     4 , "*  " ,    0 },
        /*                                               вход с символа - IPR    */
        {/*.    6     .*/     7 ,     0 , "IPR" ,    0 },
        {/*.    7     .*/     8 ,     6 , ":  " ,    0 },
        {/*.    8     .*/     9 ,     7 , "P  " ,    0 },
        {/*.    9     .*/    10 ,     8 , "R  " ,    0 },
        {/*.   10     .*/    11 ,     9 , "O  " ,    0 },
        {/*.   11     .*/    12 ,    10 , "C  " ,    0 },
        {/*.   12     .*/    13 ,    11 , "   " ,    0 },
        {/*.   13     .*/    14 ,    12 , "O  " ,    0 },
        {/*.   14     .*/    15 ,    13 , "P  " ,    0 },
        {/*.   15     .*/    16 ,    14 , "T  " ,    0 },
        {/*.   16     .*/    17 ,    15 , "I  " ,    0 },
        {/*.   17     .*/    18 ,    16 , "O  " ,    0 },
        {/*.   18     .*/    19 ,    17 , "N  " ,    0 },
        {/*.   19     .*/    20 ,    18 , "S  " ,    0 },
        {/*.   20     .*/    21 ,    19 , "(  " ,    0 },
        {/*.   21     .*/    22 ,    20 , "M  " ,    0 },
        {/*.   22     .*/    23 ,    21 , "A  " ,    0 },
        {/*.   23     .*/    24 ,    22 , "I  " ,    0 },
        {/*.   24     .*/    25 ,    23 , "N  " ,    0 },
        {/*.   25     .*/    26 ,    24 , ")  " ,    0 },
        {/*.   26     .*/    27 ,    25 , ";  " ,    0 },
        {/*.   27     .*/    28 ,    26 , "OPR" ,    0 },
        {/*.   28     .*/     0 ,    27 , "*  " ,    0 },
        /*                                               вход с символа - IDE    */
        {/*.   29     .*/    30 ,     0 , "IDE" ,    0 },
        {/*.   30     .*/    31 ,    29 , "BUK" ,   33 },
        {/*.   31     .*/    32 ,    30 , "IDE" ,    0 },
        {/*.   32     .*/     0 ,    31 , "*  " ,    0 },

        {/*.   33     .*/    34 ,    29 , "CIF" ,   36 },
        {/*.   34     .*/    35 ,    33 , "IDE" ,    0 },
        {/*.   35     .*/     0 ,    34 , "*  " ,    0 },

        {/*.   36     .*/    37 ,    29 , "IPE" ,   38 },
        {/*.   37     .*/     0 ,    36 , "*  " ,    0 },

        {/*.   38     .*/    39 ,    29 , "IPR" ,    0 },
        {/*.   39     .*/     0 ,    38 , "*  " ,    0 },
        /*                                               вход с символа - BUK    */
        {/*.   40     .*/    41 ,     0 , "BUK" ,    0 },
        {/*.   41     .*/    42 ,    40 , "IDE" ,    0 },
        {/*    42     .*/     0 ,    41 , "*  " ,    0 },
        /*                                               вход с символа - A      */
        {/*.   43     .*/    44 ,     0 , "A  " ,    0 },
        {/*.   44     .*/    45 ,    43 , "BUK" ,    0 },
        {/*.   45     .*/     0 ,    44 , "*  " ,    0 },
        /*                                               вход с символа - B      */
        {/*.   46     .*/    47 ,     0 , "B  " ,    0 },
        {/*.   47     .*/    48 ,    46 , "BUK" ,    0 },
        {/*.   48     .*/     0 ,    47 , "*  " ,    0 },
        /*                                               вход с символа - C      */
        {/*.   49     .*/    50 ,     0 , "C  " ,    0 },
        {/*.   50     .*/    51 ,    49 , "BUK" ,    0 },
        {/*.   51     .*/     0 ,    50 , "*  " ,    0 },
        /*                                               вход с символа - D      */
        {/*.   52     .*/    53 ,     0 , "D  " ,    0 },
        {/*.   53     .*/    54 ,    52 , "C  " ,  100 },
        {/*.   54     .*/    55 ,    53 , "L  " ,    0 },
        {/*.   55     .*/    56 ,    54 , "   " ,    0 },
        {/*.   56     .*/    57 ,    55 , "IPE" ,    0 },
        {/*.   57     .*/    58 ,    56 , "   " ,    0 },
        {/*.   58     .*/    59 ,    57 , "B  " ,    0 },
        {/*.   59     .*/    60 ,    58 , "I  " ,    0 },
        {/*.   60     .*/    61 ,    59 , "N  " ,   83 },
        {/*.   61     .*/    62 ,    60 , "   " ,    0 },
        {/*.   62     .*/    63 ,    61 , "F  " ,    0 },
        {/*.   63     .*/    64 ,    62 , "I  " ,    0 },
        {/*.   64     .*/    65 ,    63 , "X  " ,    0 },
        {/*.   65     .*/    66 ,    64 , "E  " ,    0 },
        {/*.   66     .*/    67 ,    65 , "D  " ,    0 },
        {/*.   67     .*/    68 ,    66 , "(  " ,    0 },
        {/*.   68     .*/    69 ,    67 , "RZR" ,    0 },
        {/*.   69     .*/    70 ,    68 , ")  " ,    0 },
        {/*.   70     .*/    71 ,    69 , "I  " ,   80 },
        {/*.   71     .*/    72 ,    70 , "N  " ,    0 },
        {/*.   72     .*/    73 ,    71 , "I  " ,    0 },
        {/*.   73     .*/    74 ,    72 , "T  " ,    0 },
        {/*.   74     .*/    75 ,    73 , "(  " ,    0 },
        {/*.   75     .*/    76 ,    74 , "LIT" ,    0 },
        {/*.   76     .*/    77 ,    75 , ")  " ,    0 },
        {/*.   77     .*/    78 ,    76 , ";  " ,    0 },
        {/*.   78     .*/    79 ,    77 , "ODC" ,    0 },
        {/*.   79     .*/     0 ,    78 , "*  " ,    0 },

        {/*.   80     .*/    81 ,    69 , ";  " ,    0 },
        {/*.   81     .*/    82 ,    80 , "ODC" ,    0 },
        {/*.   82     .*/     0 ,    81 , "*  " ,    0 },

        {/*.   83     .*/    84 ,    59 , "T  " ,    0 },
        {/*.   84     .*/    85 ,    83 , "(  " ,    0 },
        {/*.   85     .*/    86 ,    84 , "RZR" ,    0 },
        {/*.   86     .*/    87 ,    85 , ")  " ,    0 },
        {/*.   87     .*/    88 ,    86 , "I  " ,   97 },
        {/*.   88     .*/    89 ,    87 , "N  " ,    0 },
        {/*.   89     .*/    90 ,    88 , "I  " ,    0 },
        {/*.   90     .*/    91 ,    89 , "T  " ,    0 },
        {/*.   91     .*/    92 ,    90 , "(  " ,    0 },
        {/*.   92     .*/    93 ,    91 , "LIB" ,    0 },
        {/*.   93     .*/    94 ,    92 , ")  " ,    0 },
        {/*.   94     .*/    95 ,    93 , ";  " ,    0 },
        {/*.   95     .*/    96 ,    94 , "ODC" ,    0 },
        {/*.   96     .*/     0 ,    95 , "*  " ,    0 },

        {/*.   97     .*/    98 ,    86 , ";  " ,    0 },
        {/*.   98     .*/    99 ,    97 , "ODC" ,    0 },
        {/*.   99     .*/     0 ,    98 , "*  " ,    0 },

        {/*.  100     .*/   101 ,    52 , "BUK" ,    0 },
        {/*.  101     .*/     0 ,   100 , "*  " ,    0 },
        /*                                               вход с символа - E      */
        {/*.  102     .*/   103 ,     0 , "E  " ,    0 },
        {/*.  103     .*/   104 ,   102 , "N  " ,  110 },
        {/*.  104     .*/   105 ,   103 , "D  " ,    0 },
        {/*.  105     .*/   106 ,   104 , "   " ,    0 },
        {/*.  106     .*/   107 ,   105 , "IPR" ,    0 },
        {/*.  107     .*/   108 ,   106 , ";  " ,    0 },
        {/*.  108     .*/   109 ,   107 , "OEN" ,    0 },
        {/*.  109     .*/     0 ,   108 , "*  " ,    0 },

        {/*.  110     .*/   111 ,   102 , "BUK" ,    0 },
        {/*.  111     .*/     0 ,   110 , "*  " ,    0 },
        /*                                               вход с символа - M      */
        {/*.  112     .*/   113 ,     0 , "M  " ,    0 },
        {/*.  113     .*/   114 ,   112 , "BUK" ,    0 },
        {/*.  114     .*/     0 ,   113 , "*  " ,    0 },
        /*                                               вход с символа - P      */
        {/*.  115     .*/   116 ,     0 , "P  " ,    0 },
        {/*.  116     .*/   117 ,   115 , "BUK" ,    0 },
        {/*.  117     .*/     0 ,   116 , "*  " ,    0 },
        /*                                               вход с символа - X      */
        {/*.  118     .*/   119 ,     0 , "X  " ,    0 },
        {/*.  119     .*/   120 ,   118 , "BUK" ,    0 },
        {/*.  120     .*/     0 ,   119 , "*  " ,    0 },
        /*                                               вход с символа - 0      */
        {/*.  121     .*/   122 ,     0 , "0  " ,    0 },
        {/*.  122     .*/   123 ,   121 , "CIF" ,  124 },
        {/*.  123     .*/     0 ,   122 , "*  " ,    0 },

        {/*.  124     .*/   125 ,   121 , "STR" ,    0 },
        {/*.  125     .*/     0 ,   124 , "*  " ,    0 },
        /*                                               вход с символа - 1      */
        {/*.  126     .*/   127 ,     0 , "1  " ,    0 },
        {/*.  127     .*/   128 ,   126 , "CIF" ,  129 },
        {/*.  128     .*/     0 ,   127 , "*  " ,    0 },

        {/*.  129     .*/   130 ,   126 , "MAN" ,  131 },
        {/*.  130     .*/     0 ,   129 , "*  " ,    0 },

        {/*.  131     .*/   132 ,   126 , "STR" ,    0 },
        {/*.  132     .*/     0 ,   131 , "*  " ,    0 },
        /*                                               вход с символа - 2      */
        {/*.  133     .*/   134 ,     0 , "2  " ,    0 },
        {/*.  134     .*/   135 ,   133 , "CIF" ,    0 },
        {/*.  135     .*/     0 ,   134 , "*  " ,    0 },
        /*                                               вход с символа - 3      */
        {/*.  136     .*/   137 ,     0 , "3  " ,    0 },
        {/*.  137     .*/   138 ,   136 , "CIF" ,    0 },
        {/*.  138     .*/     0 ,   137 , "*  " ,    0 },
        /*                                               вход с символа - 4      */
        {/*.  139     .*/   140 ,     0 , "4  " ,    0 },
        {/*.  140     .*/   141 ,   139 , "CIF" ,    0 },
        {/*.  141     .*/     0 ,   140 , "*  " ,    0 },
        /*                                               вход с символа - 5      */
        {/*.  142     .*/   143 ,     0 , "5  " ,    0 },
        {/*.  143     .*/   144 ,   142 , "CIF" ,    0 },
        {/*.  144     .*/     0 ,   143 , "*  " ,    0 },
        /*                                               вход с символа - 6      */
        {/*.  145     .*/   146 ,     0 , "6  " ,    0 },
        {/*.  146     .*/   147 ,   145 , "CIF" ,    0 },
        {/*.  147     .*/     0 ,   146 , "*  " ,    0 },
        /*                                               вход с символа - 7      */
        {/*.  148     .*/   149 ,     0 , "7  " ,    0 },
        {/*.  149     .*/   150 ,   148 , "CIF" ,    0 },
        {/*.  150     .*/     0 ,   149 , "*  " ,    0 },
        /*                                               вход с символа - 8      */
        {/*.  151     .*/   152 ,     0 , "8  " ,    0 },
        {/*.  152     .*/   153 ,   151 , "CIF" ,    0 },
        {/*.  153     .*/     0 ,   152 , "*  " ,    0 },
        /*                                               вход с символа - 9      */
        {/*.  154     .*/   155 ,     0 , "9  " ,    0 },
        {/*.  155     .*/   156 ,   154 , "CIF" ,    0 },
        {/*.  156     .*/     0 ,   155 , "*  " ,    0 },
        /*.                                              вход с символа - ODC    */
        {/*.  157     .*/   158 ,     0 , "ODC" ,    0 },
        {/*.  158     .*/   159 ,   157 , "TEL" ,    0 },
        {/*.  159     .*/     0 ,   158 , "*  " ,    0 },
        /*.                                              вход с символа - TEL    */
        {/*.  160     .*/   161 ,     0 , "TEL" ,    0 },
        {/*.  161     .*/   162 ,   160 , "ODC" ,  164 },
        {/*.  162     .*/   163 ,   161 , "TEL" ,    0 },
        {/*.  163     .*/     0 ,   162 , "*  " ,    0 },

        {/*.  164     .*/   165 ,   160 , "OPA" ,    0 },
        {/*.  165     .*/   166 ,   164 , "TEL" ,    0 },
        {/*.  166     .*/     0 ,   165 , "*  " ,    0 },
        /*                                                вход с символа - CIF    */
        {/*.  167     .*/   168 ,     0 , "CIF" ,    0 },
        {/*.  168     .*/   169 ,   167 , "RZR" ,    0 },
        {/*.  169     .*/     0 ,   168 , "*  " ,    0 },
        /*                                               вход с символа - RZR    */
        {/*.  170     .*/   171 ,     0 , "RZR" ,    0 },
        {/*.  171     .*/   172 ,   170 , "CIF" ,    0 },
        {/*.  172     .*/   173 ,   171 , "RZR" ,    0 },
        {/*.  173     .*/     0 ,   172 , "*  " ,    0 },
        /*                                               вход с символа - MAN    */
        {/*.  174     .*/   175 ,     0 , "MAN" ,    0 },
        {/*.  175     .*/   176 ,   174 , "B  " ,  178 },
        {/*.  176     .*/   177 ,   175 , "LIT" ,    0 },
        {/*.  177     .*/     0 ,   176 , "*  " ,    0 },

        {/*.  178     .*/   179 ,   174 , "0  " ,  181 },
        {/*.  179     .*/   180 ,   178 , "MAN" ,    0 },
        {/*.  180     .*/     0 ,   179 , "*  " ,    0 },

        {/*.  181     .*/   182 ,   174 , "1  " ,    0 },
        {/*.  182     .*/   183 ,   181 , "MAN" ,    0 },
        {/*.  183     .*/     0 ,   182 , "*  " ,    0 },
        /*                                               вход с символа - '    */
        {/*.  184     .*/   185 ,     0 , "'  " ,    0 },
        {/*.  185     .*/   186 ,   184 , "STR" ,    0 },
        {/*.  186     .*/   187 ,   185 , "'  " ,    0 },
        {/*.  187     .*/   188 ,   186 , "B  " ,    0 },
        {/*.  188     .*/   189 ,   187 , "LIB" ,    0 },
        {/*.  189     .*/     0 ,   188 , "*  " ,    0 },
        /*                                               вход с символа - STR    */
        {/*.  190     .*/   191 ,     0 , "STR" ,    0 },
        {/*.  191     .*/   192 ,   190 , "0  " ,  194 },
        {/*.  192     .*/   193 ,   191 , "STR" ,    0 },
        {/*.  193     .*/     0 ,   192 , "*  " ,    0 },

        {/*.  194     .*/   195 ,   190 , "1  " ,    0 },
        {/*.  195     .*/   196 ,   194 , "STR" ,    0 },
        {/*.  196     .*/     0 ,   195 , "*  " ,    0 },
        /*                                               вход с символа - IPE    */
        {/*.  197     .*/   198 ,     0 , "IPE" ,    0 },
        {/*.  198     .*/   199 ,   197 , "=  " ,  207 },
        {/*.  199     .*/   200 ,   198 , "AVI" ,  203 },
        {/*.  200     .*/   201 ,   199 , ";  " ,    0 },
        {/*.  201     .*/   202 ,   200 , "OPA" ,    0 },
        {/*.  202     .*/     0 ,   201 , "*  " ,    0 },

        {/*.  203     .*/   204 ,   198 , "LVI" ,    0 },
        {/*.  204     .*/   205 ,   203 , ";  " ,    0 },
        {/*.  205     .*/   206 ,   204 , "OPA" ,    0 },
        {/*.  206     .*/     0 ,   205 , "*  " ,    0 },

        {/*.  207     .*/   208 ,   197 , "AVI" ,  209 },
        {/*.  208     .*/     0 ,   207 , "*  " ,    0 },

        {/*.  209     .*/   210 ,   197 , "LVI" ,    0 },
        {/*.  210     .*/     0 ,   209 , "*  " ,    0 },
        /*                                               вход с символа - LIT    */
        {/*.  211     .*/   212 ,     0 , "LIT" ,    0 },
        {/*.  212     .*/   213 ,   211 , "AVI" ,    0 },
        {/*.  213     .*/     0 ,   212 , "*  " ,    0 },
        /*.                                              вход с символа - AVI    */
        {/*.  214     .*/   215 ,     0 , "AVI" ,    0 },
        {/*.  215     .*/   216 ,   214 , "ZNK" ,    0 },
        {/*.  216     .*/   217 ,   215 , "LIT" ,  219 },
        {/*.  217     .*/   218 ,   216 , "AVI" ,    0 },
        {/*.  218     .*/     0 ,   217 , "*  " ,    0 },

        {/*.  219     .*/   220 ,   215 , "IPE" ,    0 },
        {/*.  220     .*/   221 ,   219 , "AVI" ,    0 },
        {/*.  221     .*/     0 ,   220 , "*  " ,    0 },
        /*.                                              вход с символа - LVI    */
        {/*.  222     .*/   223 ,     0 , "LVI" ,    0 },
        {/*.  223     .*/   224 ,   222 , "LOP" ,    0 },
        {/*.  224     .*/   225 ,   223 , "IPE" ,    0 },
        {/*.  225     .*/   226 ,   224 , "LVI" ,    0 },
        {/*.  226     .*/     0 ,   225 , "*  " ,    0 },
        /*                                               вход с символа - +      */
        {/*.  227     .*/   228 ,     0 , "+  " ,    0 },
        {/*.  228     .*/   229 ,   227 , "ZNK" ,    0 },
        {/*.  229     .*/     0 ,   229 , "*  " ,    0 },
        /*                                               вход с символа - -      */
        {/*.  230     .*/   231 ,     0 , "-  " ,    0 },
        {/*.  231     .*/   232 ,   230 , "ZNK" ,    0 },
        {/*.  232     .*/     0 ,   231 , "*  " ,    0 },
        /*                                               вход с символа - !      */
        {/*.  233     .*/   234 ,     0 , "!  " ,    0 },
        {/*.  234     .*/   235 ,   233 , "LOP" ,    0 },
        {/*.  235     .*/     0 ,   234 , "*  " ,    0 },
        /*                                               вход с символа - &      */
        {/*.  236     .*/   237 ,     0 , "&  " ,    0 },
        {/*.  237     .*/   238 ,   236 , "LOP" ,    0 },
        {/*.  238     .*/     0 ,   237 , "*  " ,    0 },
    };

/*
***** Т а б л и ц а  входов в "кусты" ( корней )грамматических правил,
***** содержащая тип ( терминальность или нетерминальность ) корневых
***** символов
*/

struct
{
  char SYM [4];
  int  VX;
  char TYP;
} VXOD [ NVXOD ] =
/*   __________ ___________ _____ ______
    |  NN      |    символ | вход| тип  |
    |__________|___________|_____|______|                                  */

    {
        {/*.   1     .*/   "AVI" , 214 , 'N' },
        {/*.   2     .*/   "BUK" ,  40 , 'N' },
        {/*.   3     .*/   "CIF" , 167 , 'N' },
        {/*.   4     .*/   "IDE" ,  29 , 'N' },
        {/*.   5     .*/   "IPE" , 197 , 'N' },
        {/*.   6     .*/   "IPR" ,   6 , 'N' },
        {/*.   7     .*/   "LIB" ,   0 , 'N' },
        {/*.   8     .*/   "LIT" , 211 , 'N' },
        {/*.   9     .*/   "LOP" ,   0 , 'N' },
        {/*.  10     .*/   "LVI" , 222 , 'N' },
        {/*.  11     .*/   "MAN" , 174 , 'N' },
        {/*.  12     .*/   "ODC" , 157 , 'N' },
        {/*.  13     .*/   "OEN" ,   0 , 'N' },
        {/*.  14     .*/   "OPA" ,   0 , 'N' },
        {/*.  15     .*/   "OPR" ,   1 , 'N' },
        {/*.  16     .*/   "PRO" ,   0 , 'N' },
        {/*.  17     .*/   "RZR" , 170 , 'N' },
        {/*.  18     .*/   "STR" , 190 , 'N' },
        {/*.  19     .*/   "TEL" , 160 , 'N' },
        {/*.  20     .*/   "ZNK" ,   0 , 'N' },
        {/*.  21     .*/   "A  " ,  43 , 'T' },
        {/*.  22     .*/   "B  " ,  46 , 'T' },
        {/*.  23     .*/   "C  " ,  49 , 'T' },
        {/*.  24     .*/   "D  " ,  52 , 'T' },
        {/*.  25     .*/   "E  " , 102 , 'T' },
        {/*.  26     .*/   "F  " ,   0 , 'T' },
        {/*.  27     .*/   "H  " ,   0 , 'T' },
        {/*.  28     .*/   "I  " ,   0 , 'T' },
        {/*.  29     .*/   "L  " ,   0 , 'T' },
        {/*.  30     .*/   "M  " , 112 , 'T' },
        {/*.  31     .*/   "N  " ,   0 , 'T' },
        {/*.  32     .*/   "O  " ,   0 , 'T' },
        {/*.  33     .*/   "P  " , 115 , 'T' },
        {/*.  34     .*/   "R  " ,   0 , 'T' },
        {/*.  35     .*/   "S  " ,   0 , 'T' },
        {/*.  36     .*/   "T  " ,   0 , 'T' },
        {/*.  37     .*/   "X  " , 118 , 'T' },
        {/*.  38     .*/   "0  " , 121 , 'T' },
        {/*.  39     .*/   "1  " , 126 , 'T' },
        {/*.  40     .*/   "2  " , 133 , 'T' },
        {/*.  41     .*/   "3  " , 136 , 'T' },
        {/*.  42     .*/   "4  " , 139 , 'T' },
        {/*.  43     .*/   "5  " , 142 , 'T' },
        {/*.  44     .*/   "6  " , 145 , 'T' },
        {/*.  45     .*/   "7  " , 148 , 'T' },
        {/*.  46     .*/   "8  " , 151 , 'T' },
        {/*.  47     .*/   "9  " , 154 , 'T' },
        {/*.  48     .*/   "+  " , 227 , 'T' },
        {/*.  49     .*/   "-  " , 230 , 'T' },
        {/*.  50     .*/   "!  " , 233 , 'T' },
        {/*.  51     .*/   "&  " , 236 , 'T' },
        {/*.  52     .*/   ":  " ,   0 , 'T' },
        {/*.  53     .*/   "(  " ,   0 , 'T' },
        {/*.  54     .*/   ")  " ,   0 , 'T' },
        {/*.  55     .*/   "   " ,   0 , 'T' },
        {/*.  56     .*/   ";  " ,   0 , 'T' },
        {/*.  57     .*/   "=  " ,   0 , 'T' },
        {/*.  58     .*/   "'  " , 184 , 'T' }
    };

/*
***** Т а б л и ц а  матрицы смежности - основа построения матрицы
***** преемников
*/

char TPR [ NVXOD ] [ NNETRM ] =
    {
/*
   __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
  |       AVI:BUK:CIF:IDE:IPE:IPR:LIB:LIT:LOP:LVI:MAN:ODC:OEN:OPA:OPR:PRO:RZR:STR:TEL:ZNK|
  |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */
        {/*AVI*/ 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*BUK*/ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*CIF*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0  },
        {/*IDE*/ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*IPE*/ 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*IPR*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0  },
        {/*LIB*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*LIT*/ 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*LOP*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*LVI*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*MAN*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*ODC*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0  },
        {/*OEN*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*OPA*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*OPR*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0  },
        {/*PRO*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*RZR*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0  },
        {/*STR*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0  },
        {/*TEL*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0  },
        {/*ZNK*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
/*
   __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
  |       AVI:BUK:CIF:IDE:IPE:IPR:LIB:LIT:LOP:LVI:MAN:ODC:OEN:OPA:OPR:PRO:RZR:STR:TEL:ZNK|
  |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */
        {/*  A*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  B*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  C*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  D*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  E*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  F*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  H*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  I*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  L*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  M*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  N*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  O*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  P*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  R*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  S*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  T*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  X*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
/*
   __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
  |       AVI:BUK:CIF:IDE:IPE:IPR:LIB:LIT:LOP:LVI:MAN:ODC:OEN:OPA:OPR:PRO:RZR:STR:TEL:ZNK|
  |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */
        {/*  0*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0  },
        {/*  1*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0  },
        {/*  2*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  3*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  4*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  5*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  6*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  7*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  8*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  9*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  +*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1  },
        {/*  -*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1  },
        {/*  !*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  &*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  :*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  (*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  )*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*   */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  ;*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  =*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
        {/*  '*/ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  }
/*|______________________________________________________________________________________| */
    };
/*..........................................................................*/

/*
****** Н А Ч А Л О  обработки исходного текста
*/

/*..........................................................................*/

void compress_ISXTXT () {   /* Программа уплотнения   */
  /* исходного текста путем */
  /* удаления "лишних"      */
  /* пробелов, выполняющая  */
  /* роль примитивного лек- */
  /* сического анализатора  */
  I3 = 0;
  for ( I1 = 0 ; I1 <= NISXTXT ; I1++ ) {
    for ( I2 = 0 ; I2 < 80 ; I2++ ){
      if (ISXTXT[I1][I2] != '\x0') {
        if ((ISXTXT[I1][I2] == ' ') &&
            ((PREDSYM == ' ') || (PREDSYM == ';') ||
             (PREDSYM == ')') || (PREDSYM == ':') ||
             (PREDSYM == '(')))
        {
          PREDSYM = ISXTXT[I1][I2];
          continue;
        }
        if (ISXTXT [ I1 ][ I2 ] == ' ' &&
            (PREDSYM == '+' ||
             PREDSYM == '-' ||
             PREDSYM == '=' ||
             PREDSYM == '*' ||
             PREDSYM == '!' ||
             PREDSYM == '&'))
        {
          continue;
        }


        if ((ISXTXT [ I1 ][ I2 ] == '+' ||
             ISXTXT [ I1 ][ I2 ] == '-' ||
             ISXTXT [ I1 ][ I2 ] == '=' ||
             ISXTXT [ I1 ][ I2 ] == '(' ||
             ISXTXT [ I1 ][ I2 ] == ')' ||
             ISXTXT [ I1 ][ I2 ] == '*' ||
             ISXTXT [ I1 ][ I2 ] == '!' ||
             ISXTXT [ I1 ][ I2 ] == '&') && PREDSYM == ' ')
        {
          I3-- ;
	goto L2;
               }
	L2: 
	PREDSYM = ISXTXT [ I1 ][ I2 ];
        STROKA [ I3 ] = PREDSYM;
        I3++ ;


           } else {
        break;
      }
    }
  }
  STROKA [I3] = '\x0';
}

/*..........................................................................*/

void build_TPR ()                                 /* Построение таблицы     */
/* преемников из матрицы  */
/* смежности по алгоритму */
/* Варшалла               */
{
  for ( I1 = 0; I1 < NNETRM; I1++ )
  {
    for ( I2 = 0; I2 < NVXOD; I2++ )
    {
      if ( TPR [ I2 ][ I1 ] & ( I1 != I2 ) )
      {
        for ( I3 = 0; I3 < NNETRM; I3++ )
          TPR [ I2 ][ I3 ] |= TPR [ I1 ][ I3 ];
      }
    }
  }
}

/*..........................................................................*/

void mcel ( char* T1, int T2, int T3 )          /* программа заполнения   */
{                                               /* ячейки стека поставлен-*/
  /* ных целей              */
  strcpy ( CEL [ K ].CEL1, T1 );
  CEL [ K ].CEL2 = T2;
  CEL [ K ].CEL3 = T3;
  K++;
}

/*..........................................................................*/

void mdst ( char* T1, int T2, int T3, int T4, int T5 )
{                                                /* программа заполнения   */
  strcpy ( DST [ L ].DST1, T1 );                  /* ячейки стека достигну- */
  DST [ L ].DST2 = T2;                            /* тых целей              */
  DST [ L ].DST3 = T3;
  DST [ L ].DST4 = T4;
  DST [ L ].DST5 = T5;
  L++;
}


/*..........................................................................*/
/* п р о г р а м м а      */
int numb ( char* T1, int T2 )                     /* вычисления порядкового */
/* номера строки в табл.  */
/* VXOD, соответствующей  */
/* строке-параметру функц.*/
{
  int k;

  for ( I1 = 0; I1 < NVXOD; I1++ )
  {
    for ( k = 0; k < T2; k++ )
    {
      if ( (*(T1+k) != VXOD [ I1 ].SYM [k] ) )
        goto numb1;
    }
    if ( (VXOD [ I1 ].SYM [k] == '\x0') ||
         (VXOD [ I1 ].SYM [k] == ' '  )
        )
      return ( I1 );
    numb1:
    continue;
  }
  return -1;
}

/*..........................................................................*/
/*   п р о г р а м м а    */
int sint_ANAL ()                                  /*   построения  дерева   */
/*синтаксического разбора,*/
{                                                /*выполняющая роль синтак-*/
  /*сического анализатора   */
  I4 = 0;

  L1:

  K = 0;
  L = 0;
  I = 0;
  J = 1;
  mcel ( "PRO" , I , 999 );

  if (!TPR [numb ( &STROKA [I], 1 )][numb ( "PRO", 3 )])
    return 1;

  L2:

  J = VXOD [ numb ( &STROKA [ I ], 1 ) ].VX ;

  L3:

  J = SINT [ J ].POSL;

  L31:

  I++;

  if ( I > I4 )


    I4 = I;

  if (VXOD [ numb ( SINT [ J ].DER, 3 ) ].TYP == 'T')
  {

    if ( STROKA [ I ] == SINT [ J ].DER [ 0 ] )
      goto L3;
    else
      goto L8;

  }

  L4:

  if ( SINT [ SINT [ J ].POSL ].DER [ 0 ] == '*' )
  {
    I--;

    if ( !strcmp (SINT [J].DER, CEL [K-1].CEL1 ) )
    {
      mdst ( CEL[K-1].CEL1,CEL[K-1].CEL2,CEL[K-1].CEL3,I,J );

      if ( !strcmp( CEL[K-1].CEL1 , "PRO" ) )
        return 0;

      L5:

      if (TPR [numb (CEL[K-1].CEL1, 3)] [numb (CEL[K-1].CEL1, 3)])
      {
        J = VXOD [ numb ( CEL[K-1].CEL1, 3 ) ].VX;
        goto L3;
      }

      L6:

      J = CEL[K-1].CEL3;
      K--;
      goto L3;
    }

    if (!TPR [numb (SINT[J].DER, 3)] [numb (CEL[K-1].CEL1, 3)])
      goto L9;

    mdst ( SINT[J].DER, CEL[K-1].CEL2,0,I,J );
    J = VXOD [numb (SINT[J].DER, 3)].VX;
    goto L3;
  }

  if (!TPR [numb (&STROKA [I], 1)] [numb (SINT[J].DER, 3)])
    goto L8;

  mcel ( SINT[J].DER,I,J );
  goto L2;

  L8:

  I--;

  L9:

  if (SINT[J].ALT != 0)
  {
    J = SINT[J].ALT;
    goto L31;
  }

  J = SINT[J].PRED;

  if
      (
      ( VXOD [numb (SINT[J].DER, 3)].TYP == 'N' )
      &&
      ( SINT[J].PRED > 0 )
      )
  {
    mcel (DST[L-1].DST1, DST[L-1].DST2, DST[L-1].DST3);

    L10:

    J = DST[L-1].DST5;
    L--;
    goto L9;
  }

  if
      (
      ( VXOD [numb (SINT[J].DER, 3)].TYP == 'N' )
      &&
      ( SINT[J].PRED == 0 )
      )
  {
    if (!strcmp ( CEL[K-1].CEL1, DST[L-1].DST1 ) )
      goto L6;
    else
      goto L10;
  }

  if ( SINT[J].PRED > 0 )
    goto L8;

  J = CEL[K-1].CEL3;
  K--;

  if ( J == 999 )
    return 2;
  else
    goto L8;

}

/*..........................................................................*/

struct                                            /* таблица имен меток и   */
{                                                /* переменных, заполняемая*/
  char NAME [8];                                  /* на первом проходе се-  */
  char TYPE;                                      /* мантического вычисления*/
  char RAZR [5];                                  /* и используемая на вто- */
  char INIT [50];                                 /* ром проходе семантичес-*/
} SYM [ NSYM ];                                  /* кого вычисления        */

int ISYM = 0;                                     /* текущий индекс таблицы */
/* имен                   */

char NFIL [30]="\x0";                             /* хранилище имени транс- */
/* лируемой программы     */

/*..........................................................................*/

long int VALUE ( char* s )                        /* п р о г р а м м а      */
{                                                /* перевода двоичной      */
  long int S;                                     /* константы из ASCIIz-ви-*/
  int i;                                          /* да во внутреннее пред- */
  /* ставление типа long int*/
  i = 0;
  S = 0;
  while ( *(s + i) != 'B' )

  {

    S <<= 1;
    if ( *(s + i) == '1' )
      S++;
    i++;
  }

  return (S);
}



/*..........................................................................*/
void FORM ()                                      /* п р о г р а м м а      */
{                                                /* представления фрагмента*/
  /* плотного текста в виде */
  /* массива 9-ти символьных*/
  /* лексем                 */
  int i,j;

  for ( IFORMT = 0; IFORMT < MAXFORMT; IFORMT++ )
    memcpy ( FORMT [IFORMT], "\x0\x0\x0\x0\x0\x0\x0\x0\x0", 9 );

  IFORMT = 0;
  j = DST [I2].DST2;

  FORM1:

  for ( i = j; i <= DST [I2].DST4+1; i++ )
  {
    if ( STROKA [i] == ':' || STROKA [i] == ' ' ||
         STROKA [i] == '(' || STROKA [i] == ')' ||
         STROKA [i] == ';' || STROKA [i] == '+' ||
         STROKA [i] == '-' || STROKA [i] == '=' ||
         STROKA [i] == '&' || STROKA [i] == '!' ||
         STROKA [i] == '*'
        )
    {
      FORMT [IFORMT] [i-j] = '\x0';
      IFORMT ++;
      j = i+1;
      goto FORM1;
    }
    else
      FORMT [IFORMT][i-j] = STROKA [i];

  }

  return;
}

/*..........................................................................*/
/* п р о г р а м м а      */
void ZKARD ()                                     /* записи очередной сгене-*/
{                                                /* рированной записи вы-  */
  /* ходного файла в массив */
  /* ASSTXT                 */
  char i;
  //ASS_CARD.BUFCARD[79] = '\n';
  memcpy ( ASSTXT [ IASSTXT++ ],
           ASS_CARD.BUFCARD, 80 );

  for ( i = 0; i < 79; i++ )
    ASS_CARD.BUFCARD [i] = ' ';
  return;
}

/*..........................................................................*/
/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала AVI на пер-*/
/* вом проходе.   Здесь   */
/* AVI -   "арифм.выраж." */
int AVI1 ()
{
  return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала BUK на пер-*/
/* вом проходе.   Здесь   */
/* BUK -   "буква"        */
int BUK1 ()
{
  return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала CIF на пер-*/
/* вом проходе.   Здесь   */
/* CIF -   "цифра"        */
int CIF1 ()
{
  return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала IDE на пер-*/
/* вом проходе.   Здесь   */
/* IDE -   "идентификатор"*/
int IDE1 ()
{
  return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала IPE на пер-*/
/* вом проходе.   Здесь   */
/* IPE - "имя переменной" */
int IPE1 ()
{
  return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала IPR на пер-*/
/* вом проходе.   Здесь   */
/* IPR -   "имя программы" */
int IPR1 ()
{
  return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала LIT на пер-*/
/* вом проходе.   Здесь   */
/* LIT -   "литерал"      */
int LIB1 ()
{
  return 0;
}



int LIT1 () {
  return 0;
}


int LOP1 () {
  return 0;
}


int LVI1 () {
  return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала MAN на пер-*/
/* вом проходе.   Здесь   */
/* MAN -   "мантисса"     */
int MAN1 ()
{
  return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала ODC на пер-*/
/* вом проходе.   Здесь   */
/* ODC - "операт.ПЛ1- DCL"*/
int ODC1 ()
{
  int i;
  FORM ();                                        /* форматирование ПЛ1-опе-*/
  /* ратора DCL             */

  for ( i = 0; i < ISYM; i++ )                    /* если фиксируем повтор- */
  {                                              /* повторное объявление   */
    if (  !strcmp ( SYM [i].NAME, FORMT [1] ) &&  /* второго терма оператора*/
          strlen ( SYM [i].NAME ) ==              /* DCL, то                */
          strlen ( FORMT [1] )
        )
      return 6;                                    /* завершение программы   */
    /* по ошибке              */
  }

  if (!strcmp (FORMT[2], "BIN")) {
    strcpy ( SYM [ISYM].NAME, FORMT [1] );        /* при отсутствии повтор- */
    strcpy ( SYM [ISYM].RAZR, FORMT [4] );        /* ного объявления иденти-*/
    /* фикатора запоминаем его*/
    /* вместе с разрядностью в*/
    /* табл.SYM               */
  } else if (!strcmp (FORMT[2], "BIT")) {
    strcpy ( SYM [ISYM].NAME, FORMT[1] );
    strcpy ( SYM [ISYM].RAZR, FORMT[3] );
  } else {
    return 6;
  }

  if ( !strcmp ( FORMT [2], "BIN" ) &&            /* если идентификатор оп- */
       !strcmp ( FORMT [3], "FIXED" ) )/* ределен как bin fixed, */
  {
    SYM [ISYM].TYPE = 'B';                        /* то устанавливаем тип   */
    /* идентификатора = 'B' и */
    goto ODC11;                                   /* идем на продолжение об-*/
    /* работки, а             */
  }
  else if (!strcmp (FORMT[2], "BIT")) {
    SYM[ISYM].TYPE = 'T'; // bit == type T
    if (!strcmp (FORMT[4], "INIT")) {
      strcpy (SYM[ISYM++].INIT, FORMT[5]);
    } else {
      strcpy (SYM[ISYM++].INIT, "'0'B");
    }
    return 0;
  }
  else                                            /* иначе                  */
  {
    SYM [ISYM].TYPE = 'U';                        /* устанавливаем тип иден-*/
    /* тификатора = 'U'  и    */
    return 2;                                     /* завершаем программу    */
    /* по ошибке              */
  }

  ODC11:                                            /* если идентификатор     */
  /* имеет начальную иници- */
  if ( !strcmp ( FORMT [5], "INIT" )  )           /* ализацию, то запомина- */
    strcpy ( SYM [ISYM++].INIT, FORMT [6] );       /* ем в табл. SYM это на- */
    /* чальное значение, а    */
  else                                            /* иначе                  */
    strcpy ( SYM [ISYM++].INIT, "0B" );            /* инициализируем иденти- */
  /* фикатор нулем          */

  return 0;                                      /* успешное завешение     */
  /* программы              */
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала OEN на пер-*/
/* вом проходе.   Здесь   */
/* OEN - "операт.ПЛ1-END" */
int OEN1 ()
{
  char i = 0;
  FORM ();                                        /* форматирование ПЛ1-опе-*/
  /* ратора END             */

  for ( i = 0; i < ISYM; i++ )                    /* если вторй терм опера- */
    /* тора END записан в табл*/
  {                                              /* SYM и его тип = "P",то:*/
    if ( !strcmp ( SYM [i].NAME, FORMT [1] ) &&
         (SYM [i].TYPE == 'P') &&
         strlen (SYM [i].NAME) ==
         strlen ( FORMT [1] ) )
      return 0;                                    /* успешное завершение    */
    /* программы              */
  }

  return 1;                                       /* иначе завершение прог- */
  /* раммы по ошибке        */
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала OPA на пер-*/
/* вом проходе.   Здесь   */
/* OPA - "операт.присваи- */
/* вания арифметический   */
int OPA1 ()
{
  return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала OPR на пер-*/
/* вом проходе.   Здесь   */
/* OPR - "операт.ПЛ1-PROC"*/
int OPR1 ()
{
  FORM ();                                        /* форматируем оператор   */
  /* ПЛ1 PROC               */

  strcpy ( SYM [ISYM].NAME, FORMT [0] );          /* перепишем имя ПЛ1-прог-*/
  /* раммы в табл. SYM,     */

  SYM [ISYM].TYPE   = 'P';                        /* установим тип этого    */
  /* имени = 'P'            */
  SYM [ISYM++].RAZR [0] = '\x0';                  /* установим разрядность  */
  /* равной 0               */

  return 0;                                       /* успешное завершение    */
  /* программы              */
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала PRO на пер-*/
/* вом проходе.   Здесь   */
/* PRO - "программа"      */

int PRO1 ()
{
  return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала RZR на пер-*/
/* вом проходе.   Здесь   */
/* RZR - "разрядность"    */

int RZR1 ()
{
  return 0;
}

int STR1 () {
  return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала TEL на пер-*/
/* вом проходе.   Здесь   */
/* TEL - "тело программы" */

int TEL1 ()
{
  return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала ZNK на пер-*/
/* вом проходе.   Здесь   */
/* ZNK - "знак операции"  */

int ZNK1 ()
{
  return 0;
}

/* FINISHED */

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала AVI на вто-*/
/* ром проходе.   Здесь   */
/* AVI -   "арифм.выраж." */


int AVI2 ()
{
  char i;
  FORM ();                                        /*форматируем правую часть*/
  /*арифметического ПЛ1-опе-*/
  /*ратора присваивания     */

  if ( IFORMT == 1 )                              /* если правая часть одно-*/
  {                                            /* термовая, то:          */
    for ( i = 0; i < ISYM; i++ )                  /* ищем этот терм в табли-*/
    {                                            /* це имен  и             */
      if ( !strcmp ( SYM [i].NAME, FORMT [0] )  &&/* если находим, то:      */
           strlen ( SYM [i].NAME ) ==
           strlen ( FORMT [0] )
          )
      {
        if ( SYM [i].TYPE == 'B' )              /* в случае типа=bin fixed*/
        {

          if ( strcmp ( SYM [i].RAZR, "15" )    /* и разрядности <= 15    */
               <= 0 )
            memcpy ( ASS_CARD._BUFCARD.OPERAC,   /* формируем код ассембле-*/
                     "LH", 2 );/* ровской операции LH,   */
          else
            memcpy ( ASS_CARD._BUFCARD.OPERAC,   /* а при разрядности >15  */
                     "L", 1 );/* формируем код ассембле-*/
          /* ровской операции L     */

          strcpy ( ASS_CARD._BUFCARD.OPERAND,   /*       формируем        */
                   "@RRAB," );/*       первый  и        */
          strcat ( ASS_CARD._BUFCARD.OPERAND,   /* второй операнды ассемб-*/
                   FORMT [0]);/* леровской операции     */

          ASS_CARD._BUFCARD.OPERAND [ strlen    /* вставляем разделитель  */
              ( ASS_CARD._BUFCARD.OPERAND ) ] = ' ';

          memcpy ( ASS_CARD._BUFCARD.COMM,      /* и построчный коментарий*/
                   "3arpy3ka nepeMeHHou' B perucTp", 30 );

          ZKARD ();                             /* запомнить операцию ас- */
          /* семблера  и            */
          return 0;                             /* завершить программу    */
        }
        else
          return 3;                              /* если тип терма не bin  */
        /* fixed,то выход по ошиб-*/
        /* ке                     */
      }
    }
    return 4;                                     /* если терм-идентификатор*/
    /* неопределен, то выход  */
    /* по ошибке              */
  }
  else                                            /* если правая часть ариф-*/
    /* метического выражения  */
    /* двухтермовая, то:      */
  {
    for ( i = 0; i < ISYM; i++ )                  /* если правый терм ариф- */
    {                                            /* метического выражения  */
      if ( !strcmp ( SYM [i].NAME,                /*определен в табл.SYM,то:*/
                     FORMT [IFORMT-1] )  &&
           strlen ( SYM [i].NAME ) ==
           strlen ( FORMT [IFORMT-1] )
          )
      {
        if ( SYM [i].TYPE == 'B' )              /* если тип правого опе-  */
        {                                      /* ранда bin fixed, то:   */

          if ( STROKA [ DST [I2].DST4 -         /* если знак опер."+",то: */
                        strlen( FORMT [IFORMT-1] ) ] == '+' )
          {
            if ( strcmp ( SYM [i].RAZR, "15" )  /* если разрядность прав. */
                 <= 0 )/* операнда <= 15, то:    */
              memcpy ( ASS_CARD._BUFCARD.OPERAC,
                       "AH", 2 );/* формируем код ассембле-*/
            else                                /* ровской операции "AH",а*/
              memcpy ( ASS_CARD._BUFCARD.OPERAC,
                       "A", 1 );/* иначе - "A"            */
          }

          else

          {
            if ( STROKA [ DST [I2].DST4 -       /* если же знак операции  */
                          strlen ( FORMT [IFORMT-1] ) ] == /* арифметического выра-  */
                 '-' )/* жения "-", то:         */

            {
              if ( strcmp ( SYM [i].RAZR, "15" )/* при разрядности ариф-  */
                   <= 0 )/* метич.выраж.<= 15      */
                memcpy( ASS_CARD._BUFCARD.OPERAC,/* формируем код ассембле-*/
                        "SH", 2 );/* ровской операции "SH",F*/
              else
                memcpy( ASS_CARD._BUFCARD.OPERAC,/* иначе - "S"            */
                        "S", 1 );
            }

            else

              return 5;                          /* если знак операции не  */
            /* "+" и не "-", то завер-*/
            /* шение  программы  по   */
            /* ошибке                 */
          }
          /* формируем:             */
          strcpy ( ASS_CARD._BUFCARD.OPERAND,   /* - первый операнд ассем-*/
                   "@RRAB," );/*блеровской операции;    */
          strcat ( ASS_CARD._BUFCARD.OPERAND,   /* - второй операнд ассем-*/
                   FORMT [IFORMT-1] );/*блеровской операции;    */
          ASS_CARD._BUFCARD.OPERAND [ strlen
              ( ASS_CARD._BUFCARD.OPERAND )] =/* - разделяющий пробел;  */
              ' ';
          memcpy ( ASS_CARD._BUFCARD.COMM,
                   "qpopmupoBaHue npome}l{yTo4Horo 3Ha4eHu9",/* - построчный коментарий*/
                   39 );
          ZKARD ();                             /* запоминание ассембле-  */
          /* ровской операции       */

          return 0;                             /* успешное завершение    */
          /* пограммы               */
        }
        else
          return 3;                              /* если тип правого опе-  */
        /* ранда арифметического  */
        /* выражения не bin fixed,*/
        /* то завершение програм- */
        /* мы по ошибке           */
      }
    }
    return 4;                                     /* если правый операнд    */
    /* арифметического выраже-*/
    /*ния не определен в табл.*/
    /* SYM, то завершить про- */
    /* грамму по ошибке       */
  }

}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала BUK на вто-*/
/* ром проходе.   Здесь   */
/* BUK -   "буква"        */

int BUK2 ()
{
  return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала CIF на вто-*/
/* ром проходе.   Здесь   */
/* CIF -   "цифра"        */

int CIF2 ()
{
  return 0;
}

/*..........................................................................*/


/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала IDE на вто-*/
/* ром проходе.   Здесь   */
/* IDE -   "идентификатор"*/

int IDE2 ()
{
  return 0;
}


/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала IPE на вто-*/
/* ром проходе.   Здесь   */
/* IPE - "имя переменной" */

int IPE2 ()
{
  return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала IPR на вто-*/
/* ром проходе.   Здесь   */
/* IPR -   "имя программы" */

int IPR2 ()
{
  return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала LIT на вто-*/
/* ром проходе.   Здесь   */
/* LIT -   "литерал"      */

int LIB2 () {
  return 0;
}

int LIT2 ()
{
  return 0;
}

int LOP2 () {
  return 0;
}

/*done*/
int LVI2 () {
  char i;
  FORM ();                /*форматируем правую часть*/
  /*арифметического ПЛ1-опе-*/
  /*ратора присваивания     */

  if ( IFORMT == 1 )                                  /* если правая часть одно-*/
  {                                                   /* термовая, то:          */
    for ( i = 0; i < ISYM; i++ )                      /* ищем этот терм в табли-*/
    {                                                /* це имен  и             */
      if ( !strcmp (SYM[i].NAME, FORMT[0])  &&    /* если находим, то:      */
           strlen (SYM[i].NAME) == strlen (FORMT[0]))
      {
        if ( SYM [i].TYPE == 'T' )              /* в случае типа=bit*/
        {

          if (strcmp (SYM[i].RAZR, "16") <= 0) {    /* и разрядности <= 2 byte    */

            memcpy (ASS_CARD._BUFCARD.OPERAC, "LH", 2);  /* формируем код ассембле-*/
            /* ровской операции LH,   */
          } else {
            memcpy ( ASS_CARD._BUFCARD.OPERAC, "L", 1 );  /* а при разрядности > 2 byte  */
            /* формируем код ассембле-*/
            /* ровской операции L     */
          }

          strcpy ( ASS_CARD._BUFCARD.OPERAND,   /*       формируем        */
                   "@RRAB," );/*       первый  и        */
          strcat ( ASS_CARD._BUFCARD.OPERAND,   /* второй операнды ассемб-*/
                   FORMT [0]);/* леровской операции     */

          ASS_CARD._BUFCARD.OPERAND [ strlen    /* вставляем разделитель  */
              ( ASS_CARD._BUFCARD.OPERAND ) ] = ' ';

          memcpy ( ASS_CARD._BUFCARD.COMM,      /* и построчный коментарий*/
                   "3arpy3ka nepeMeHHou' B perucTp", 30 );

          ZKARD ();                             /* запомнить операцию ас- */
          /* семблера  и            */
          return 0;                             /* завершить программу    */
        }
        else
          return 3;                              /* если тип терма не bit,  */
        /* то выход по ошибке*/
      }
    }
    return 4;                                     /* если терм-идентификатор*/
    /* неопределен, то выход  */
    /* по ошибке              */
  }
  else                                            /* если правая часть ариф-*/
    /* метического выражения  */
    /* двухтермовая, то:      */
  {
    for ( i = 0; i < ISYM; i++ )                  /* если правый терм ариф- */
    {                                            /* метического выражения  */
      if ( !strcmp (SYM[i].NAME,                 /*определен в табл.SYM,то:*/
                    FORMT[IFORMT-1])  &&
           strlen (SYM[i].NAME) ==
           strlen ( FORMT [IFORMT-1] )
          )
      {
        if ( SYM [i].TYPE == 'T' )              /* если тип правого опе-  */
        {                                      /* ранда bit, то:   */
          /*Write FORMT[IFORM-1] to @RRAB1*/
          if (strcmp (SYM[i].RAZR, "16") <= 0) {    /* и разрядности <= 2 byte    */
            memcpy (ASS_CARD._BUFCARD.OPERAC, "LH", 2);  /* формируем код ассембле-*/
            /* ровской операции LH,   */
          } else {
            memcpy ( ASS_CARD._BUFCARD.OPERAC, "L", 1 );  /* а при разрядности > 2 byte  */
            /* формируем код ассембле-*/
            /* ровской операции L     */
          }
          strcpy ( ASS_CARD._BUFCARD.OPERAND, "@RRAB1," );
          strcat ( ASS_CARD._BUFCARD.OPERAND, FORMT [IFORMT-1]);
          ASS_CARD._BUFCARD.OPERAND [strlen (ASS_CARD._BUFCARD.OPERAND)] = ' ';
          memcpy ( ASS_CARD._BUFCARD.COMM, "3arpy3ka nepeMeHHou' B perucTp", 30 );
          ZKARD ();

          if ( STROKA [ DST [I2].DST4 -         /* если знак опер."!",то: */
                        strlen( FORMT [IFORMT-1] ) ] == '!' )
          {
            memcpy (ASS_CARD._BUFCARD.OPERAC, "OR", 2);
          } else {
            if ( STROKA [DST[I2].DST4 - strlen (FORMT[IFORMT-1]) ] == '&' ) {
              memcpy(ASS_CARD._BUFCARD.OPERAC, "NR", 2);
            } else {
              return 5;
            }
          }
          /* формируем:             */
          strcpy ( ASS_CARD._BUFCARD.OPERAND,   /* - первый операнд ассем-*/
                   "@RRAB," );/*блеровской операции;    */
          strcat ( ASS_CARD._BUFCARD.OPERAND,   /* - второй операнд ассем-*/
                   "@RRAB1" );/*блеровской операции;    */
          ASS_CARD._BUFCARD.OPERAND [ strlen
              ( ASS_CARD._BUFCARD.OPERAND )] =/* - разделяющий пробел;  */
              ' ';
          memcpy ( ASS_CARD._BUFCARD.COMM,
                   "qpopMupoBaHue npoMe}l{yTo4Horo 3Ha4eHu9", 39 );
          ZKARD ();                             /* запоминание ассембле-  */
          /* ровской операции       */

          return 0;                             /* успешное завершение    */
          /* пограммы               */
        }
        else
          return 3;                              /* если тип правого опе-  */
        /* ранда арифметического  */
        /* выражения не bit,*/
        /* то завершение програм- */
        /* мы по ошибке           */
      }
    }
    return 4;                                     /* если правый операнд    */
    /* арифметического выраже-*/
    /*ния не определен в табл.*/
    /* SYM, то завершить про- */
    /* грамму по ошибке       */
  }
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала MAN на вто-*/
/* ром проходе.   Здесь   */
/* MAN -   "мантисса"     */

int MAN2 ()
{
  return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала ODC на вто-*/
/* ром проходе.   Здесь   */
/* ODC - "операт.ПЛ1- DCL"*/

int ODC2 ()
{
  return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала OEN на вто-*/
/* ром проходе.   Здесь   */
/* OEN - "операт.ПЛ1-END" */

/* программа    формирует */
/* эпилог ассемблеровского*/
/* эквивалента ПЛ1-прог-  */
/* раммы                  */
int OEN2 ()
{
  char RAB [20];
  char i = 0;
  FORM ();                                        /* форматируем ПЛ1-опера- */
  /* тор END                */

  memcpy ( ASS_CARD._BUFCARD.OPERAC, "BCR", 3 );  /* формируем код безуслов-*/
  /*ного возврата управления*/
  /* в вызывающую программу */

  memcpy ( ASS_CARD._BUFCARD.OPERAND,"15,14", 5 );/* операнды команды и     */

  memcpy ( ASS_CARD._BUFCARD.COMM,                /* поле построчного комен-*/
           "Bblxog u3 nporpaMMbl", 20 );/* тария                  */

  ZKARD ();                                       /* запомнить опреацию     */
  /* Ассемблера             */

  /* далее идет блок форми- */
  /* рования декларативных  */
  /* псевдоопераций DC для  */
  /* каждого идентификатора,*/
  /* попавшего в табл.SYM   */
  for ( i = 0; i < ISYM; i++ )
  {                                              /* если строка табл.SYM   */
    if ( isalpha ( SYM [i].NAME [0] ) )           /* содержит идентификатор,*/
      /* т.е.начинается с буквы,*/
    {                                            /* то:                    */
      if ( SYM [i].TYPE == 'B' )                  /* если тип оператора bin */
        /* fixed, то:             */
      {
        strcpy ( ASS_CARD._BUFCARD.METKA,         /* пишем идентификатор в  */
                 SYM [i].NAME ); /* поле метки псевдоопера-*/
        /* ции DC                 */
        ASS_CARD._BUFCARD.METKA [ strlen
            ( ASS_CARD._BUFCARD.METKA ) ] = ' '; /* пишем разделитель полей*/

        memcpy ( ASS_CARD._BUFCARD.OPERAC,        /* пишем код псевдоопера- */
                 "DC", 2 ); /* ции DC                 */

        if ( strcmp ( SYM [i].RAZR, "15" ) <= 0 ) /* формируем операнды псе-*/
          /* вдооперации DC         */
          strcpy ( ASS_CARD._BUFCARD.OPERAND,      /* для случая полуслова   */
                   "H\'" );
        else                                      /* или                    */

          strcpy ( ASS_CARD._BUFCARD.OPERAND,      /* для случая слова       */					 "F\'" );

//Dos command
//	strcat ( ASS_CARD._BUFCARD.OPERAND,       /* формируем цифровую     */
//		 ltoa ( VALUE (SYM [i].INIT),     /* часть операнда псевдо- */
//				 &RAB [0], 10) ); /* операции,              */
//let's do that in Unix!
        strcat(ASS_CARD._BUFCARD.OPERAND, gcvt(VALUE(SYM[i].INIT), 10, &RAB[0]));
        ASS_CARD._BUFCARD.OPERAND [ strlen        /* замыкающий апостроф    */
            ( ASS_CARD._BUFCARD.OPERAND ) ] = '\'';  /*          и             */

        memcpy ( ASS_CARD._BUFCARD.COMM,          /* поле построчного комен-*/
                 "onpegeJIeHue nepeMeHHou'", 24 );  /* тария                  */

        ZKARD ();                                 /* запомнить операцию     */
        /*    Ассемблера          */
      } else if (SYM[i].TYPE == 'T') {
          memcpy ( ASS_CARD._BUFCARD.OPERAC, "DS", 2 );
          strcpy (ASS_CARD._BUFCARD.OPERAND, "0H");
          ASS_CARD._BUFCARD.OPERAND [strlen (ASS_CARD._BUFCARD.OPERAND)] = ' ';
          memcpy (ASS_CARD._BUFCARD.COMM, "BblpaBHuBaHue Ha 2 6au'Ta", 25);
          ZKARD ();
          strcpy (ASS_CARD._BUFCARD.METKA, SYM[i].NAME);
          ASS_CARD._BUFCARD.METKA [strlen (ASS_CARD._BUFCARD.METKA)] = ' ';
        if (strcmp (SYM[i].INIT,"'0'B")) {
          memcpy (ASS_CARD._BUFCARD.OPERAC, "DC", 2);
          strcpy (ASS_CARD._BUFCARD.OPERAND, "BL2");
          strncpy (RAB, SYM[i].INIT, strlen (SYM[i].INIT) - 1);
          RAB[strlen (SYM[i].INIT)-1] = '\0';
          strcat (ASS_CARD._BUFCARD.OPERAND, RAB);
          ASS_CARD._BUFCARD.OPERAND [strlen (ASS_CARD._BUFCARD.OPERAND)] = ' ';
          memcpy (ASS_CARD._BUFCARD.COMM, "Define var", 10);
          ZKARD ();
	  
//          memcpy(ASS_CARD._BUFCARD.OPERAC, "DC", 2);
//          strcpy(ASS_CARD._BUFCARD.OPERAND, "H'");
//          strcat(ASS_CARD._BUFCARD.OPERAND, SYM[i].RAZR);
//          strcat(ASS_CARD._BUFCARD.OPERAND, "'");
//          ASS_CARD._BUFCARD.OPERAND [strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
//          memcpy (ASS_CARD._BUFCARD.COMM, "Capacity", 8);
//          ZKARD();

          memcpy(ASS_CARD._BUFCARD.OPERAC, "DC", 2);
          strcpy(ASS_CARD._BUFCARD.OPERAND, "H'");
          char str_size[3];
          snprintf(str_size, 3, "%d", strlen(SYM[i].INIT) - 3);
          strcat(ASS_CARD._BUFCARD.OPERAND, str_size);
          strcat(ASS_CARD._BUFCARD.OPERAND, "'");
          ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
          memcpy(ASS_CARD._BUFCARD.COMM, "Size", 4);
          ZKARD();
	  
        } else {
          memcpy ( ASS_CARD._BUFCARD.OPERAC, "DS", 2 );
          strcpy (ASS_CARD._BUFCARD.OPERAND, "BL2");
          ASS_CARD._BUFCARD.OPERAND [strlen (ASS_CARD._BUFCARD.OPERAND)] = ' ';
          memcpy (ASS_CARD._BUFCARD.COMM, "Define var", 10);
          ZKARD ();
        }
      }
    }
  }
  /* далее идет блок декла- */
  /* ративных ассемблеровс- */
  /* ких EQU-операторов, оп-*/
  /* ределяющих базовый и   */
  /* рабочий регистры общего*/
  /* назначения             */

  memcpy ( ASS_CARD._BUFCARD.METKA, "@RBASE", 6 ); /* формирование EQU-псев- */
  memcpy ( ASS_CARD._BUFCARD.OPERAC, "EQU",3 );   /* дооперации определения */
  memcpy ( ASS_CARD._BUFCARD.OPERAND, "2", 1 );  /* номера базового регист-*/
  /* ра общего назначения   */
  /*           и            */
  ZKARD ();                                       /* запоминание ее         */

  memcpy ( ASS_CARD._BUFCARD.METKA, "@RRAB", 5 );  /* формирование EQU-псев- */
  memcpy ( ASS_CARD._BUFCARD.OPERAC, "EQU",3 );   /* дооперации определения */
  memcpy ( ASS_CARD._BUFCARD.OPERAND, "3", 1 );   /* номера базового регист-*/
  /* ра общего назначения   */
  /*            и           */
  ZKARD ();                                       /* запоминание ее         */

  memcpy ( ASS_CARD._BUFCARD.METKA, "@RRAB1", 6 );  /* формирование EQU-псев- */
  memcpy ( ASS_CARD._BUFCARD.OPERAC, "EQU",3 );   /* дооперации определения */
  memcpy ( ASS_CARD._BUFCARD.OPERAND, "4", 1 );   /* номера базового регист-*/
  /* ра общего назначения   */
  /*            и           */
  ZKARD ();                                       /* запоминание ее         */

  //Probably remove
  memcpy ( ASS_CARD._BUFCARD.OPERAC, "END", 3 );  /* формирование кода ас-  */
  /* семблеровской псевдо-  */
  /* операции END,          */
  i = 0;

  while ( FORMT [1][i] != '\x0' )                 /* ее операнда            */
    ASS_CARD._BUFCARD.OPERAND [i] = FORMT [1][i++];/*         и              */

  memcpy ( ASS_CARD._BUFCARD.COMM,                /* построчного коментария */
           "KoHeLL nporpaMMbl", 17 );

  ZKARD ();                                       /* запоминание псевдоопе- */
  /* рации                  */

  return 0;                                       /* завершение программы   */
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала OPA на вто-*/
/* ром проходе.   Здесь   */
/* OPA - "операт.присваи- */
/* вания арифметический   */

int OPA2 ()
{
  int i;

  FORM ();                                        /*форматируем ПЛ1-оператор*/
  /*присваивания арифметич. */

  for ( i = 0; i < ISYM; i++ )
  {                                              /* если идентификатор пра-*/
    /* вой части оператора оп-*/
    if ( !strcmp ( SYM [i].NAME, FORMT [0] )  &&  /* ределен ранее через    */
         strlen ( SYM [i].NAME ) ==               /* оператор DCL, то:      */
         strlen ( FORMT [0] )
        )
    {
      if ( SYM [i].TYPE == 'B' )              /* если этот идентификатор*/
      {                                      /* имеет тип bin fixed,то:*/

        if ( strcmp ( SYM [i].RAZR, "15" )    /* если bin fixed (15),то:*/
             <= 0 )
          memcpy ( ASS_CARD._BUFCARD.OPERAC,   /* сформировать команду   */
                   "STH", 3 );/* записи полуслова       */

        else                                  /* иначе:                 */
          memcpy ( ASS_CARD._BUFCARD.OPERAC,   /* команду записи слова   */
                   "ST", 2 );

        strcpy ( ASS_CARD._BUFCARD.OPERAND,   /*       доформировать    */
                 "@RRAB," );/*          операнды      */

        strcat ( ASS_CARD._BUFCARD.OPERAND,   /*           команды      */
                 FORMT [0]) ;

        ASS_CARD._BUFCARD.OPERAND [ strlen    /*              и         */
            ( ASS_CARD._BUFCARD.OPERAND ) ] = ' ';

        memcpy ( ASS_CARD._BUFCARD.COMM,      /* построчный коментарий  */
                 "qpopMupoBaHue 3Ha4eHu9 apuqpM Bblpa}l{eHu9",
                 42 );
        ZKARD ();                             /* запомнить операцию     */
        /* Ассемблера  и          */
        return 0;                             /* завершить программу    */
      } else if (SYM[i].TYPE == 'T') {
        memcpy ( ASS_CARD._BUFCARD.OPERAC, "STH", 3);
        strcpy ( ASS_CARD._BUFCARD.OPERAND, "@RRAB,");
        strcat ( ASS_CARD._BUFCARD.OPERAND, FORMT[0]) ;
        ASS_CARD._BUFCARD.OPERAND [strlen (ASS_CARD._BUFCARD.OPERAND)] = ' ';
        memcpy ( ASS_CARD._BUFCARD.COMM, "qpopMupoBaHue 3Ha4eHu9 apuqpM Bblpa}l{eHu9", 42 );
        ZKARD ();
        return 0;
      }

      else                                    /* если идентификатор не  */
        /* имеет тип bin fixed,то:*/
        return 3;                              /* завершение с диагности-*/
      /* кой ошибки             */
    }
  }
  return 4;                                       /* если идентификатор ра- */
  /* нее не определен через */
  /* ПЛ1-оператор DCL,то за-*/
  /* вершение с диагностикой*/
  /* ошибки                 */

}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала OPR на вто-*/
/* ром проходе.   Здесь   */
/* OPR - "операт.ПЛ1-PROC"*/

/* программа    формирует */
/* пролог ассемблеровского*/
/* эквивалента  исходной  */
/* ПЛ1-программы          */
int OPR2 ()
{
  char i = 0;
  FORM ();                                        /* форматируем оператор   */
  /* ПЛ1 - "начало процедур-*/
  /* ного блока"            */
  while ( FORMT [0][i] != '\x0' )
    ASS_CARD._BUFCARD.METKA [i++] = FORMT [0][i];  /* нулевой терм используем*/
  /* как метку в START-псев-*/
  /* дооперации Ассемблера  */

  memcpy ( ASS_CARD._BUFCARD.OPERAC, "START", 5 );/* достраиваем код и опе- */
  memcpy ( ASS_CARD._BUFCARD.OPERAND, "0", 1 );   /* ранды  в  START-псевдо-*/
  memcpy ( ASS_CARD._BUFCARD.COMM,                /* операции Ассемблера    */
           "Ha4aJIo nporpaMMbl", 18 );
  ZKARD ();                                       /* запоминаем карту Ассем-*/
  /* блера                  */

  memcpy ( ASS_CARD._BUFCARD.OPERAC, "BALR", 4 ); /* формируем BALR-операцию*/
  memcpy ( ASS_CARD._BUFCARD.OPERAND,             /* Ассемблера             */
           "@RBASE,0", 8 );
  memcpy ( ASS_CARD._BUFCARD.COMM,
           "3arpy3uTb perucTp 6a3bl", 23 );
  ZKARD ();                                       /* и запоминаем ее        */

  memcpy ( ASS_CARD._BUFCARD.OPERAC, "USING", 5 );/* формируем USING-псевдо-*/
  memcpy ( ASS_CARD._BUFCARD.OPERAND,             /* операцию Ассемблера    */
           "*,@RBASE", 8 );
  memcpy ( ASS_CARD._BUFCARD.COMM,
           "Ha3Ha4uTb perucTp 6a3ou'", 24 );
  ZKARD ();                                       /* и запоминаем ее        */

  return 0;                                       /* завершить подпрограмму */
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала PRO на вто-*/
/* ром проходе.   Здесь   */
/* PRO - "программа"      */

int PRO2 ()                                       /*прогр.формирует выходной*/
{                                                /*файл                    */

  FILE *fp;                                       /*набор                   */
  /*рабочих                 */
  /*переменных              */

  strcat ( NFIL , "ass" );                        /*сформировать имя выход- */
  /*ного файла              */

  if ( (fp = fopen ( NFIL , "wb" )) == NULL )     /*при неудачн.открыт.ф-ла */
    return (7);                                    /* сообщение об ошибке    */

  else                                            /*иначе:                  */
    fwrite (ASSTXT, 80 , IASSTXT , fp);            /* формируем тело об.файла*/
  fclose ( fp );                                  /*закрываем об'ектный файл*/
  return ( 0 );                                   /*завершить полдпрограмму */
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала RZR на вто-*/
/* ром проходе.   Здесь   */
/* RZR - "разрядность"    */

int RZR2 ()
{
  return 0;
}

int STR2 () {
  return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала TEL на вто-*/
/* ром проходе.   Здесь   */
/* TEL - "тело программы" */

int TEL2 ()
{
  return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала ZNK на вто-*/
/* ром проходе.   Здесь   */
/* ZNK - "знак операции"  */

int ZNK2 ()
{
  return 0;
}

/*..........................................................................*/

/*  п р о г р а м м а     */
/* управления абстрактной */
/* ЭВМ  -  семантического */
/* вычислителя, интерпре- */
/* тирующего абстрактную  */
/* программу, сформирован-*/
/* ную синтаксическим ана-*/
/* лизатором в стеке дос- */
/* тигнутых целей.        */

/* Суть алгоритма управле-*/
/*ния  в  последовательной*/
int gen_COD ()                                    /*интерпретации строк сте-*/
{                                                /*ка достижений  в направ-*/
  int NOSH;                                       /*лении от дна к вершине. */

  int (* FUN [NNETRM][2]) () =                    /*При этом каждая строка  */
      {                                              /*воспринимается как кома-*/
          {/*    1  */    AVI1, AVI2 },                /*нда абстрактной ЭВМ со  */
          {/*    2  */    BUK1, BUK2 },                /*следующими полями:      */
          {/*    3  */    CIF1, CIF2 },
          {/*    4  */    IDE1, IDE2 },		  /* - DST.DST1 - код опера-*/
          {/*    5  */    IPE1, IPE2 },      	  /*ции;                    */
          {/*    6  */    IPR1, IPR2 },
          {/*    7  */    LIB1, LIB2 },
          {/*    8  */    LIT1, LIT2 },            	  /* - DST.DST2 - левая гра-*/
          {/*    9  */    LOP1, LOP2 },
          {/*   10  */    LVI1, LVI2 },
          {/*   11  */    MAN1, MAN2 },		  /*ница интерпретируемого  */
          {/*   12  */    ODC1, ODC2 },		  /*фрагмента исх.текста;   */
          {/*   13  */    OEN1, OEN2 },
          {/*   14  */    OPA1, OPA2 },		  /* - DST.DST4 -правая гра-*/
          {/*   15  */    OPR1, OPR2 },		  /*ница интерпретируемого  */
          {/*   16  */    PRO1, PRO2 },		  /*фрагмента исх.текста.   */
          {/*   17  */    RZR1, RZR2 },
          {/*   18  */    STR1, STR2 },
          {/*   19  */    TEL1, TEL2 },
          {/*   20  */    ZNK1, ZNK2 }
      };

  for ( I2 = 0; I2 < L; I2++ )                    /* организация первого    */
    if ( ( NOSH = FUN [                            /* прохода семантического */
        numb ( DST [I2].DST1, 3 )   /* вычисления             */
    ][0] ()
         ) != 0
        )
      return (NOSH);                                /* выход из программы     */
  /* по ошибке              */

  for ( I2 = 0; I2 < L; I2++ )                    /* организация второго    */
    if ( ( NOSH = FUN [                            /* прохода семантического */
        numb ( DST [I2].DST1, 3 )   /* вычисления             */
    ][1] ()
         ) != 0
        )
      return (NOSH);                                /* выход из программы     */
  /* по ошибке              */

  return 0;                                       /* успешное завершение    */
  /* программы              */
}

/*..........................................................................*/

/*  п р о г р а м м а,    */
/* организующая последова-*/
/* тельную обработку ис-  */
/* ходного текста:        */
/* - лексич.анализатором; */
/* - синтаксич.анализат.; */
/* - семантич.вычислителем*/
int main (int argc, char **argv )
{                                                /* рабочие переменные:    */
  FILE *fp;                                       /* - указатель на файл;   */
  char *ptr=argv[1];                              /* - указатель на первый  */
  /*параметр командной стр. */

  strcpy ( NFIL, ptr );                           /*изъять имя транслируемой*/
  /*программы из командной  */
  /*строки в рабочее поле   */

  /*проверяем корректность  */
  /*командной строки        */
  if ( argc != 2 )

  {                                              /* по ошибке в командн.стр*/
    printf ("%s\n", "Ошибка в командной строке"); /* выдать диагностику и   */
    return 0;                                       /* завершить трансляцию   */
  }

  /* проверка типа исх.файла*/
  if
      (
      strcmp ( &NFIL [ strlen ( NFIL )-3 ], "pli" ) /* если тип не "pli", то: */
      )

  {
    printf ( "%s\n",                              /* выдать диагностику и   */
             "Неверный тип файла с исходным текстом" );
    return 0;                                       /* завершить трансляцию   */
  }


  else                                            /* если тип файла "pli",то*/

  {                                              /*пытаемся открыть файл и */
    if ( (fp = fopen ( NFIL , "rb" )) == NULL )   /*при неудачн.открыт.ф-ла */
      /* сообщение об ошибке и  */
    {
      printf ( "%s\n",
               "Не найден файл с исходным текстом" );
      return 0;                                     /* завершение трансляции  */
    }

    else                                          /* иначе:                 */
      /* пишем файл в массив    */
      /*  ISXTXT                */
    {
      for ( NISXTXT = 0; NISXTXT <= MAXNISXTXT; NISXTXT++ )

      {
        if ( !fread ( ISXTXT [NISXTXT], 80, 1, fp ) )
        {
          if ( feof ( fp ) )                      /* в конце файла идем на  */
            goto main1;                            /* метку  main1           */

          else                                    /* при сбое чтения        */
          {                                      /* выдаем диагностику     */
            printf ( "%s\n",
                     "Ошибка при чтении фыйла с исх.текстом" );
            return 0;                               /* и завершаем трансляцию */
          }
        }
      }

      printf ( "%s\n",                            /*при пеерполнении массива*/
               "Переполнение буфера чтения исх.текста" ); /* ISXTXT выдать диагн.   */
      return 0;                                     /* и завершить трансляцию */
    }

  }

  main1:                                            /* по завершении чтения   */
  /* исх.файла формируем    */
  fclose ( fp );                                 /* префикс имени выходного*/
  NFIL [ strlen ( NFIL )-3 ] = '\x0';            /* Ассемблеровского файла */

  memset ( ASS_CARD.BUFCARD, ' ', 80 );           /* чистка буфера строки   */
  /* выходного ассемблеров- */
  /* ского файла            */

  compress_ISXTXT ();                             /* лексический анализ     */
  /* исходного текста       */
  build_TPR ();                                   /* построение матрицы     */
  /* преемников             */

  if ( (sint_ANAL ()) )                           /* синтаксический анализ  */
  {                                              /* исходного текста       */
    STROKA [I4 +20] = '\x0';
    printf                                       /* если найдены ошибки    */
        (                                           /* синтаксиса, то :       */
            "%s%s%s%s\n",
            "ошибка синтаксиса в исх.тексте -> ",      /* выдаем диагностику и   */
            "\"...",&STROKA [I4], "...\""
        );
    printf
        (
            "%s\n", "трансляция прервана"
        );
    return 0;                                      /* завершаем трансляцию   */
  }
  else                                            /* иначе делаем           */
  {
    switch ( gen_COD () )                         /* семантическое вычислен.*/
    {
      case  0:                                    /*если код завершения = 0,*/
        /* то:                    */

        printf ( "%s\n",                           /* - диагностич.сообщение;*/
                 "трансляция завершена успешно" );
        return 0;                                    /* - завершить трансляцию */


      case  1:                                    /*если код завершения = 1,*/
        /* то:                    */
        printf ( "%s\n",                           /* - диагностич.сообщение;*/
                 "несовпадение имени процедуры в прологе-эпилоге" );
        break;                                     /* - выйти на обобщающую  *//* - диагностич.сообщение;*/
        /*диагностику             */

      case  2:                                    /*если код завершения = 2,*/
        /* то:                    */
        STROKA [ DST [I2].DST2 +20 ] = '\x0';      /* - диагностич.сообщение;*/
        printf ( "%s%s\n%s%s%s\n",
                 "недопустимый тип идентификатора: ",
                 &FORMT [1], " в исх.тексте -> \"...",
                 &STROKA [ DST [I2].DST2 ], "...\"" );
        break;                                     /* - выйти на обобщающую  */
        /*диагностику             */

      case  3:                                    /*если код завершения = 3,*/
        /* то:                    */
        STROKA [ DST [I2].DST2 + 20 ] = '\x0';     /* - диагностич.сообщение;*/
        printf ( "%s%s\n%s%s%s\n",
                 "недопустимый тип идентификатора: ",
                 &FORMT [IFORMT-1], " в исх.тексте -> \"...",
                 &STROKA [ DST [I2].DST2 ], "...\"" );
        break;                                     /* -выйти на обобщающую   */
        /*диагностику             */

      case  4:                                    /*если код завершения = 4,*/
        /* то:                    */
        STROKA [ DST [I2].DST2 + 20 ] = '\x0';     /* - диагностич.сообщение;*/
        printf ( "%s%s\n%s%s%s\n",
                 "неопределенный идентификатор: ",
                 &FORMT [IFORMT-1], " в исх.тексте -> \"...",
                 &STROKA [ DST [I2].DST2 ], "...\"" );
        break;                                     /* - выйти на обобщающую  */
        /*диагностику             */

      case  5:                                    /*если код завершения = 5,*/
        /* то:                    */
        STROKA [ DST [I2].DST2 + 20 ] = '\x0';     /* - диагностич.сообщение;*/
        printf ( "%s%c\n%s%s%s\n",
                 "недопустимая операция: ",
                 STROKA [ DST [I2].DST4 - strlen ( FORMT [IFORMT-1] ) ],
                 " в исх.тексте -> \"...", &STROKA [ DST [I2].DST2 ], "...\"");
        break;                                     /* - выйти на обобщающую  */
        /*диагностику             */

      case  6:                                    /*если код завершения = 6 */
        /* то:                    */
        STROKA [ DST [I2].DST2 + 20 ] = '\x0';     /* - диагностич.сообщение;*/
        printf ( "%s%s\n%s%s%s\n",
                 "повторное объявление идентификатора: ",
                 &FORMT [1], " в исх.тексте -> \"...",
                 &STROKA [ DST [I2].DST2 ], "...\"" );
        break;                                     /* - выйти на обобщающую  */
        /*диагностику             */

    }

  }

  printf ( "%s\n", "трансляция прервана" );       /* обобщающая диагностика */

  return 0;
}
/*..........................................................................*/
